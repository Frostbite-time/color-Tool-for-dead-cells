第一步，将节点图拆成小图，对小图进行循环处理
第二步，遍历全图，删减每个节点部分的像素点数量，使之只存有一个像素点。存有的像素点应当为那一块像素的中点
第三步，找到图片中最上方的灰色像素，作为类似坐标原点的东西。记录它
第四步，定义一个结构（这一步应当提前），结构能存储2个像素点的全部坐标信息并且能存储一个用于标记部位的量（可以是字符串，可以是），开辟一个这种结构的数组，数组长度大约100。
第五步，遍历图像中所有仍然存在的点，记录他们的坐标和颜色信息（你可以再定义并声明一个合适的结构数组来记录）。
第六步，遍历那个记录了坐标和颜色信息的数组，把他们中每个元素与坐标原点的距离坐标信息记录下来，对于不同的颜色分别记录到不同的结构数组中（记得提前定义适合的结构数组，另外记得避开坐标原点本身）
第七步，遍历数组，整理下标的位置，将下标按照与原点距离来排序
第八步，按照下标把像素点对应的坐标记录到之前声明的 能存储2个像素点的全部坐标信息并且能存储一个用于标记部位的量 的结构数组
例如，有这样一个数组a[100]，将 a[0] a[1]中存储的坐标信息记录到那个结构数组中，然后到a[1] a[2] 以此类推（即使这种算法可能有误差，但是以我的观察，误差理论很小）
记得，对于a[100]一定要先进行初始化，将他们的值设置为一个不可能的值以便后面用if排除a[100]中多余的数组元素
第九步，此时，我们之前声明的 能存储2个像素点的全部坐标信息并且能存储一个用于标记部位的量 的结构数组记录的元素实际就代表一个部位了

最后，只需要按我之前说的标准向量偏移什么的把你画的图拼上去就好了。至于部位之间距离没有你的图大，那就在你画图之前先取一个适当的平均大小。然后在拼上去先根据部位间距离进行放缩。opencv有提供
放缩的函数

